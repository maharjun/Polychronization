function [ varargout ] = PlotSpikePropagation(InputStruct, GenerationTimeVect, SpikeSynIndVect )
%PLOTSPIKEPROPAGATION Plots the spike Propagation graph allowing for 1 time
%step delay
%   
%   [fig]       = PlotSpikePropagation( GenerationTimeVect, SpikeSynIndVect )
%   [A, C]      = PlotSpikePropagation( GenerationTimeVect, SpikeSynIndVect )
%   [fig, A, C] = PlotSpikePropagation( GenerationTimeVect, SpikeSynIndVect )
% 
% Return Values:
% 
%   fig - handle to the figure generated
%     A - cell array :: A{1} = Adj Mat for immediate propagation
%         and A{2} for delayed propagation
%     C - Coordinates
% 
% Input Arguments:
% 
%   InputStruct        - InputStruct as returned from TimeDelNetSim 
%                        containing network and onemsbyTstep information
%   GenerationTimeVect - As returned by ParseSpikeList
%   SpikeSynIndVect    - As returned by ParseSpikeList
% 
% Function Description:
%   
%   This function plots the spike propagation graph inferred from the
%   vector of spikes (GenerationTimeVect, SpikeSynIndVect) and the network
%   information in InputStruct.
%   
%   The graph of spike propagations that have resulted in a spike the
%   moment the spike has arrived has edges in RED.
%   
%   The graph of spike propagations that have resulted in a spike the
%   moment one ms after the spike has arrived has edges in GREEN.

N = length(InputStruct.a);
BegTime = min(GenerationTimeVect);
EndTime = max(GenerationTimeVect)+1;
TimeRange = EndTime + double(InputStruct.onemsbyTstep*InputStruct.DelayRange) - BegTime;

% Initializing Spike Property Vectors
SpikePreSynNeuronVect = double(InputStruct.NStart(SpikeSynIndVect));
SpikePostSynNeuronVect = double(InputStruct.NEnd(SpikeSynIndVect));
SpikeDelayVect        = double(double(InputStruct.onemsbyTstep)*InputStruct.Delay(SpikeSynIndVect));

% Calculating Arrival Times
ArrivalTimeVect = GenerationTimeVect + double(SpikeDelayVect);

% Creating sparse SpikeMat to store arriving and Generated spikes
GeneratedSpikeMat = sparse(double(SpikePreSynNeuronVect), double(GenerationTimeVect) - BegTime + 1, ones(length(GenerationTimeVect), 1), N, double(TimeRange));
ArrivalSpikeMat = sparse(double(SpikePostSynNeuronVect), double(ArrivalTimeVect) - BegTime + 1, ones(length(ArrivalTimeVect), 1), N, double(TimeRange));

% Only keeping those arriving spikes which generated a spike on arriving
	ArrivalSpikeMatFiltered = boolean(ArrivalSpikeMat) & boolean(GeneratedSpikeMat);
	% Find the index of these spikes (index vector)
		EffectiveArrivedSpikes = find(ArrivalSpikeMatFiltered((ArrivalTimeVect - BegTime)*N + double(SpikePostSynNeuronVect)));
	% Find the index of the spikes generated by above valid spikes (index vector)
		[~, EffectivelyGeneratedSpikes] = ismember([ArrivalTimeVect(EffectiveArrivedSpikes), SpikePostSynNeuronVect(EffectiveArrivedSpikes)], ...
											[GenerationTimeVect, SpikePreSynNeuronVect], 'rows');
		EffectiveArrivedSpikes = EffectiveArrivedSpikes(EffectivelyGeneratedSpikes ~= 0);
		EffectivelyGeneratedSpikes = EffectivelyGeneratedSpikes(EffectivelyGeneratedSpikes ~= 0);
	% Filtering out spikes that end in an inhibitory neuron
		EffectiveArrivedSpikes     = EffectiveArrivedSpikes    (SpikePostSynNeuronVect(EffectiveArrivedSpikes)     <= 800);
		EffectivelyGeneratedSpikes = EffectivelyGeneratedSpikes(SpikePreSynNeuronVect (EffectivelyGeneratedSpikes) <= 800);
	% Filtering out spikes that start in an inhibitory neuron
		EffectivelyGeneratedSpikes = EffectivelyGeneratedSpikes(SpikePreSynNeuronVect(EffectiveArrivedSpikes) <= 800);
		EffectiveArrivedSpikes     = EffectiveArrivedSpikes    (SpikePreSynNeuronVect(EffectiveArrivedSpikes) <= 800);

% Only keeping those arriving spikes which generated a spike 1ms after arriving
	ArrivalSpikeMatFiltered = [boolean(ArrivalSpikeMat(:, 1:end-1)) & boolean(GeneratedSpikeMat(:, 2:end)), false(size(ArrivalSpikeMat,1),1)];
	% Find the index of these spikes (index vector)
		DelayEffectiveArrivedSpikes = find(ArrivalSpikeMatFiltered((ArrivalTimeVect - BegTime)*N + double(SpikePostSynNeuronVect)));
	% Find the index of the spikes generated by above valid spikes (index)
		[~, DelayEffectivelyGeneratedSpikes] = ismember([ArrivalTimeVect(DelayEffectiveArrivedSpikes)+1, SpikePostSynNeuronVect(DelayEffectiveArrivedSpikes)], ...
											[GenerationTimeVect, SpikePreSynNeuronVect], 'rows');
		DelayEffectiveArrivedSpikes = DelayEffectiveArrivedSpikes(DelayEffectivelyGeneratedSpikes ~= 0);
		DelayEffectivelyGeneratedSpikes = DelayEffectivelyGeneratedSpikes(DelayEffectivelyGeneratedSpikes ~= 0);
	% Filtering out spikes that end in an inhibitory neuron
		DelayEffectiveArrivedSpikes     = DelayEffectiveArrivedSpikes    (SpikePostSynNeuronVect(DelayEffectiveArrivedSpikes)     <= 800);
		DelayEffectivelyGeneratedSpikes = DelayEffectivelyGeneratedSpikes(SpikePreSynNeuronVect (DelayEffectivelyGeneratedSpikes) <= 800);
	% Filtering out spikes that start in an inhibitory neuron
		DelayEffectivelyGeneratedSpikes = DelayEffectivelyGeneratedSpikes(SpikePreSynNeuronVect(DelayEffectiveArrivedSpikes) <= 800);
		DelayEffectiveArrivedSpikes     = DelayEffectiveArrivedSpikes    (SpikePreSynNeuronVect(DelayEffectiveArrivedSpikes) <= 800);


% Create Sparse Adjacency Matrix
EffectiveSpikeMovementGraph = sparse(EffectiveArrivedSpikes, EffectivelyGeneratedSpikes, ...
                                true(length(EffectivelyGeneratedSpikes), 1), ...
	                            length(GenerationTimeVect), length(GenerationTimeVect));

DelayEffectiveSpikeMovementGraph = sparse(DelayEffectiveArrivedSpikes, DelayEffectivelyGeneratedSpikes, true(length(DelayEffectivelyGeneratedSpikes), 1), ...
	                                 length(GenerationTimeVect), length(GenerationTimeVect));

if nargout == 1 || nargout == 3
	varargout{1} = figure;
elseif nargout == 0
	figure;
end

if nargout == 1 || nargout == 3 || nargout == 0
	gplot(EffectiveSpikeMovementGraph, [GenerationTimeVect/1000, SpikePreSynNeuronVect], '-r');
	hold on;
	gplot(DelayEffectiveSpikeMovementGraph, [GenerationTimeVect/1000, SpikePreSynNeuronVect], '-g');
	plot(double(GenerationTimeVect/1000), double(SpikePreSynNeuronVect), '.', 'MarkerSize', 5);
end

if nargout == 2
	varargout{1} = cell(2,1);
	varargout{1}{1} = EffectiveSpikeMovementGraph;
	varargout{1}{2} = DelayEffectiveSpikeMovementGraph;
	varargout{2}    = [GenerationTimeVect/(double(InputStruct.onemsbyTstep)*1000), SpikePreSynNeuronVect];
end

end